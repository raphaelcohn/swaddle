# GitHub uses <Link>, pagination, Hypermedia, HATEOAS and URI templates as they're cool and fully RESTful
# This just increases the pain of using their API from a command line. Roy Fielding was very clever in defining REST, but not everything REST is pragmatic.
# Pagination is a horrid idea. What kind of server or client can't cope with a few 100 lines? It pushes state management all over the place. And it's usually broken - the ranges change between requests, so items move pages, and so disappear, or appear twice. It takes all of the worst ideas from database result set cursors, and pushes them into the web of 2014.
# A programmatically navigable API seems nice, until you realise that a client doesn't have a foggiest what all those link relations mean.
# Doesn't know what the data schema is for every resource. And lastly, why, is it good to allow 'URLs to change' if Roy Fielding's 'this allows people to do long-term design right' - "too many APIs are short-term", if in such omnipotent forethought one needs new URL structures. It the URL structure is now self-described, why change it? Frankly, every example I've seen is pretty moot. And the efficiency of parsing such designs, without allowing 'just go there' access is appalling, as well as convoluted and complex (and much more work, with a lot more parsing).
# URI templates are a nice idea, but the vagueness of the rules (eg variable names can also be percent encoded, if not, need percent encoding), the "don't output the prefix if all expansions are null" (which requires one to cache the entire output, just in case), the '+' operator (yuck, special encoding rules for literals which all of a sudden aren't quite literal, with a special case for % again requiring look-ahead), yuck and list / map explosion (depending on what the binder decides, not the template) are another mess - by the same crowd. It would have been VERY simple to just say "the rest of the URL is treated as already encoded. Variables should be encoded." HTTP with REST-like APIs won out because of simplicity and sanity. Frankly, the worst examples are the HTTP Accept-* and Content-* headers, which are badly implemented everywhere, not least in the one web server the web big wigs personally hack on - Apache. Frankly, %-encoding itself is another mess (at least 4 contradictory RFCs, special rules for form bodies, and no one even questions why it is necessary in 2014).
# It seems REST has now gained the "enterprise tooling" and "self describing schema stuff" we loathed about WS-DeathStar.

# JSON awk: https://github.com/step-/JSON.awk
# JSON.awk beats JSON.sh on time, but doesn't work with Mac OS X awk or mawk
# Still have json-bash to try - currently needs bash
# Also http://kmkeen.com/jshon/ , is a call-out, but seems effective

core_usesIn curl
core_usesIn urlencode

github_api_v3_initialise()
{
	local tokenFilePath="$1"
	
	if [ $# -eq 2 ]; then
		# eg https://{server}/api/v3
		github_api_v3_endpoint="$2"
	else
		github_api_v3_endpoint='https://api.github.com'
	fi
	
	local githubOAuth2PersonalAccessToken="$(<"$tokenFilePath")"
	github_api_v3_user="${githubOAuth2PersonalAccessToken}:x-oauth-basic"
	
	local TMP_FILE
	core_temporaryFiles_newFileToRemoveOnExit
	github_api_v3_requestFilePath="$TMP_FILE"
	
	local TMP_FILE
	core_temporaryFiles_newFileToRemoveOnExit
	github_api_v3_responseFilePath="$TMP_FILE"
}

_github_api_v3_relative()
{
	local verb="$1"
	local relativePath="$2"
	shift 2
	
	if core_variable_isUnset github_api_v3_endpoint; then
		core_exitError $core_commandLine_exitCode_SOFTWARE "Please initialise first using 'github_api_v3_initialise' (to set 'github_api_v3_endpoint')"
	fi
	
	_github_api_v3_absolute "$verb" "${github_api_v3_endpoint}${relativePath}" "$@"
}

_github_api_v3_absolute()
{
	local verb="$1"
	local url="$2"
	shift 2
	
	if core_variable_isUnset github_api_v3_user; then
		core_exitError $core_commandLine_exitCode_SOFTWARE "Please initialise first using 'github_api_v3_initialise' (to set 'github_api_v3_user')"
	fi
	
	# As an alternative to setting user, we can set a header: 'Authorization' "token ${github_api_v3_oauth2Token}"
	set -- "Accept" 'application/vnd.github.v3+json' "$@"
	
	local curl_uploadFile="$github_api_v3_requestFilePath"
	
	local curl_httpVersion curl_httpCode curl_httpDescription
	curl_retrieve basic "$github_api_v3_user" "$verb" "$url" "$github_api_v3_responseFilePath" "$@"
	
	case $curl_httpVersion in
		
		# Bad Request (we sent an invalid JSON)
		400)
			core_exitError $core_commandLine_exitCode_DATAERR "HTTP Error '$curl_httpCode': '$(github_api_v3_errorMessage)'"
		;;
		
		# Unprocessable Entity (we sent an invalid field in the body)
		422)
			core_exitError $core_commandLine_exitCode_USAGE "HTTP Error '$curl_httpCode': '$(github_api_v3_errorMessage)'"
		;;
		
		# Unauthorized (not always)
		401)
			core_exitError $core_commandLine_exitCode_DATAERR "HTTP Error '$curl_httpCode': '$(github_api_v3_errorMessage)'"
		;;
		
		# Unauthorized or Rate-Limited
		403)
			core_exitError $core_commandLine_exitCode_DATAERR "HTTP Error '$curl_httpCode': '$(github_api_v3_errorMessage)'"
		;;
		
	esac
}

core_dependency_requires '*' jshon
github_api_v3_errorMessage()
{
	# My issues with jshon are:-
	# - Not possible to extract multiple fields, tab-separated
	# - Doesn't correctly handle empty (either omits, or display an empty array when nested results were asked for)
	# https://github.com/ddopson/underscore-cli
	# https://stedolan.github.io/jq/
	# TickTock and others, of course
	jshon -e message -u "$github_api_v3_responseFilePath"
}

_github_api_v3_relative_GET()
{
	local relativePath="$1"
	shift 1
	
	printf '' >"$github_api_v3_requestFilePath"
	_github_api_v3_relative GET "$relativePath" "$@"
}

_github_api_v3_relative_POST()
{
	local relativePath="$1"
	shift 1
	
	_github_api_v3_relative POST "$relativePath" 'Content-Type' 'application/json' "$@"
}

_github_api_v3_relative_PATCH()
{
	local relativePath="$1"
	shift 1
	
	_github_api_v3_relative PATCH "$relativePath" 'Content-Type' 'application/json' "$@"
}

core_dependency_requires '*' jshon
core_usesIn jsonwriter

github_api_v3_releases_list()
{
	local owner="$1"
	local repo="$2"
	
	_github_api_v3_relative_GET "/repos/$(urlencode_pathPiece "$owner")/$(urlencode_pathPiece "$repo")/releases"
	
	# jq is very nice, but --join-output isn't implemented in 1.4, making it less useful.
	# jq --raw-output '.[]|.url,.id' <x
	cat "$github_api_v3_responseFilePath"
	exit 99
}

github_api_v3_releases_create()
{
	local owner="$1"
	local repo="$2"
	
	local tagName="$3"
	local commitish="$4"
	local name="$5"
	local description="$6"
	local draft="$7"
	local prerelease="$8"
	
	jsonwriter_object \
			string tag_name "$tagName" \
			string target_commitish "$commitish" \
			string name "$name" \
			string body "$body" \
			boolean draft "$draft" \
			boolean prerelease "$prerelease" \
	>"$github_api_v3_postInputFile"
	
	_github_api_v3_relative_POST "/repos/$(urlencode_pathPiece "$owner")/$(urlencode_pathPiece "$repo")/releases"
}
