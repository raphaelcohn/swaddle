core_usesIn swaddle/build/package deb rpm tar
core_usesIn swaddle fakeroot
core_usesIn swaddle touch
core_usesIn configure

swaddle_build_package()
{
	core_functions_execute _swaddle_build_package_functions "$@"
}

core_functions_register _swaddle_build_package_functions swaddle_build_package_createTemporaryFolder
swaddle_build_package_createTemporaryFolder()
{
	_swaddle_build_package_temporaryFolderPath="$_swaddle_build_temporaryFolderPath"/"$_swaddle_build_package_kind"
	mkdir -m 0700 -p "$_swaddle_build_package_temporaryFolderPath"
}

core_dependency_requires '*' mkdir
core_functions_register _swaddle_build_package_functions swaddle_build_package_createRootFolder
swaddle_build_package_createRootFolder()
{
	_swaddle_build_package_root="$_swaddle_build_package_temporaryFolderPath"/root
	mkdir -m 0755 -p "$_swaddle_build_package_root"
}

core_functions_register _swaddle_build_package_functions swaddle_build_package_registerConfiguration
core_dependency_requires '*' git awk
swaddle_build_package_registerConfiguration()
{
	configure_register Value Architecture swaddle architecture  'all'
	configure_register Value NotEmpty swaddle epoch '0'
	configure_register Value NotEmpty swaddle version '0'
	# iteration is bumped by one for RPMs
	configure_register Value NotEmpty swaddle iteration '1'
	
	configure_register Value NotEmpty swaddle vendor
	configure_register Value Licence swaddle licence
	configure_register Value NotEmpty swaddle maintainer
	configure_register Value NotEmpty swaddle description
	configure_register Value NotEmpty swaddle url
	
	configure_register Value NotEmpty swaddle timestamp 0
	
	configure_register Value NotEmpty swaddle fix_permissions 'swaddle_build_package_defaultFixPermissions'
	
	swaddle_build_package_${_swaddle_build_package_kind}_registerConfiguration
}

swaddle_build_package_defaultFixPermissions()
{
	_swaddle_build_package_defaultFixPermissions_recurse()
	{
		local filePath="$1"
		if [ -e "$filePath" ]; then
			swaddle_touch_setMtimeAndAtime "$timestamp" "$filePath"
			
			if [ -L "$filePath" ]; then
				return 0
			fi
			
			if [ -d "$filePath" ]; then
				local subPath
				for subPath in "$filePath"/*
				do
					_swaddle_build_package_defaultFixPermissions_recurse "$subPath"
				done
			fi
		fi
	}

	local pathToBodyOrSkeleton="$1"
	local timestamp="$(configure_getConfigurationSetting swaddle timestamp)"
	_swaddle_build_package_defaultFixPermissions_recurse "$pathToBodyOrSkeleton"
}

core_functions_register _swaddle_build_package_functions swaddle_build_package_resetConfiguration
swaddle_build_package_resetConfiguration()
{
	configure_reset swaddle
	configure_reset swaddle_${_swaddle_build_package_kind}
}

core_functions_register _swaddle_build_package_functions swaddle_build_package_sourceConfiguration
swaddle_build_package_sourceConfiguration()
{
	configure_source "$_swaddle_build_sourcePath" package
	configure_source "$_swaddle_build_sourcePath"/packages/"$_swaddle_build_package_kind" "$_swaddle_build_package_kind"
}

core_functions_register _swaddle_build_package_functions swaddle_build_package_validateConfiguration
swaddle_build_package_validateConfiguration()
{
	configure_validate swaddle
	configure_validate swaddle_${_swaddle_build_package_kind}
}

core_dependency_requires '*' rsync sort rm mkdir sort
core_functions_register _swaddle_build_package_functions swaddle_build_package_synchroniseToPackageRoot
swaddle_build_package_synchroniseToPackageRoot()
{
	_swaddle_build_package_rootFakerootFilePath="$_swaddle_build_package_root".fakeroot
	
	local destinationFakerootTemporaryFilePath="$_swaddle_build_package_root".fakeroot.tmp
	rm -f "$destinationFakerootTemporaryFilePath"

	local fixPermissionsBinaryOrFunction="$(configure_getConfigurationSetting swaddle fix_permissions)"
	
	# If there are file conflicts (eg same file in multiple structures), first sync source wins
	set --
	local folderStructurePath
	local fakerootEnvironmentFilePath
	for folderStructurePath in \
		"$_swaddle_build_sourcePath"/packages/"$_swaddle_build_package_kind"/body \
		"$_swaddle_build_sourcePath"/packages/"$_swaddle_build_package_kind"/skeleton \
		"$_swaddle_build_sourcePath"/body \
		"$_swaddle_build_sourcePath"/skeleton
	do
		fakerootEnvironmentFilePath="$folderStructurePath".fakeroot
		if [ -f "$fakerootEnvironmentFilePath" ]; then
			cat "$fakerootEnvironmentFilePath" >>"$destinationFakerootTemporaryFilePath"
		fi
		
		# We do this before checking the path exists, so they can create it, too
		if [ -n "$fixPermissionsBinaryOrFunction" ]; then
			swaddle_fakeroot $fixPermissionsBinaryOrFunction "$folderStructurePath"
		fi
		
		if ! core_path_isReadableAndSearchableFolderPath "$folderStructurePath"; then
			continue
		fi
		
		# Trailing '\' matters to rsync, remember!
		set -- "$@" "$folderStructurePath"/
	done
	
	if [ $# -eq 0 ]; then
		core_message WARN "There are no skeleton or body folders to include the package. This is probably not what you want."
		
		# Ensure the package root is completely clean
		rm -rf "$_swaddle_build_package_root"
		mkdir -m 0755 -p "$_swaddle_build_package_root"
		return 0
	fi

	if [ -f "$destinationFakerootFilePath" ]; then
		cat "$destinationFakerootFilePath" >>"$destinationFakerootTemporaryFilePath"
	fi
	sort -u "$destinationFakerootTemporaryFilePath" >"$destinationFakerootFilePath"
	rm "$destinationFakerootTemporaryFilePath"
	
	swaddle_fakeroot "$_swaddle_build_package_rootFakerootFilePath" "$_swaddle_build_package_rootFakerootFilePath" rsync --quiet --archive --acls --xattrs --hard-links --delete --delete-after --delete-excluded --exclude=.gitignore "$@" "$_swaddle_build_package_root"/
}

core_functions_register _swaddle_build_package_functions swaddle_build_package_kind
swaddle_build_package_kind()
{
	swaddle_build_package_${_swaddle_build_package_kind}
}
