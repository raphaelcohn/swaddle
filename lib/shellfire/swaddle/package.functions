core_usesIn core functions variable variable/array

swaddle_package_build()
{
	local swaddle_package="$core_variable_array_element"
	core_functions_execute _swaddle_package_functions "$@"
}

core_functions_register _swaddle_package_functions swaddle_package_setPackageSwaddlePath
swaddle_package_setPackageSwaddlePath()
{
	_swaddle_package_swaddlePath="$swaddle_swaddlePath"/"$swaddle_package"
	
	if ! core_path_isReadableAndSearchableFolderPath "$_swaddle_package_swaddlePath"; then
		core_exitError "$core_commandLine_exitCode_USAGE" "Please ensure the package '$swaddle_package' exists as a readable, searchable folder in '$swaddle_swaddlePath'."
	fi
}

core_dependency_requires '*' rm mkdir
core_functions_register _swaddle_package_functions swaddle_package_createTemporaryFolder
swaddle_package_createTemporaryFolder()
{
	_swaddle_package_temporaryFolderPath="$swaddle_temporaryPackagesFolderPath"/"$swaddle_package"
	rm -rf "$_swaddle_package_temporaryFolderPath" 2>/dev/null || true
	mkdir -m 0700 -p "$_swaddle_package_temporaryFolderPath"
}

core_dependency_requires '*' rm mkdir
core_functions_register _swaddle_package_functions swaddle_package_createWorkFolder
swaddle_package_createWorkFolder()
{
	_swaddle_package_workFolderPath="$swaddle_temporaryPackagesFolderPath"/"$swaddle_package"/work
	rm -rf "$_swaddle_package_workFolderPath" 2>/dev/null || true
	mkdir -m 0700 -p "$_swaddle_package_workFolderPath"
}

core_dependency_requires '*' rm mkdir
core_functions_register _swaddle_package_functions swaddle_package_createGeneratedScriptsFolder
swaddle_package_createGeneratedScriptsFolder()
{
	_swaddle_package_generatedScriptsFolderPath="$swaddle_temporaryPackagesFolderPath"/"$swaddle_package"/generated-scripts
	rm -rf "$_swaddle_package_generatedScriptsFolderPath" 2>/dev/null || true
	mkdir -m 0700 -p "$_swaddle_package_generatedScriptsFolderPath"
}

core_dependency_requires '*' mkdir
core_functions_register _swaddle_package_functions swaddle_package_createPackageRootFolder
swaddle_package_createPackageRootFolder()
{
	_swaddle_package_root="$_swaddle_package_temporaryFolderPath"/root
	mkdir -m 0755 -p "$_swaddle_package_root"
}

core_functions_register _swaddle_package_functions swaddle_package_setScriptsFolder
swaddle_package_setScriptsFolder()
{
	_swaddle_package_scriptsFolderPath="$_swaddle_package_swaddlePath"/scripts
}

core_functions_register _swaddle_package_functions swaddle_package_resetConfiguration
swaddle_package_resetConfiguration()
{
	unset swaddle_architecture
	unset swaddle_epoch
	unset swaddle_version
	unset swaddle_iteration
	unset swaddle_vendor
	unset swaddle_licence
	unset swaddle_category
	unset swaddle_maintainer
	unset swaddle_description
	unset swaddle_url
	core_variable_array_unset swaddle_configFiles
	core_variable_array_unset swaddle_directories

	core_variable_array_unset swaddle_rpm_depends
	unset swaddle_rpm_autoDepends
	core_variable_array_unset swaddle_rpm_provides
	core_variable_array_unset swaddle_rpm_conflicts
	core_variable_array_unset swaddle_rpm_replaces
	unset swaddle_rpm_user
	unset swaddle_rpm_group
	unset swaddle_rpm_defattrfile
	unset swaddle_rpm_defattrdir
	unset swaddle_rpm_digest
	unset swaddle_rpm_compression
	unset swaddle_rpm_sign
	unset swaddle_rpm_autoAddDirectories
	unset swaddle_rpm_autoReqProv
	unset swaddle_rpm_autoReq
	unset swaddle_rpm_autoProv
	unset swaddle_rpm_ignoreIterationInDependencies
	unset swaddle_rpm_regexFilterFromProvides
	unset swaddle_rpm_regexFilterFromRequires
	core_variable_array_unset swaddle_rpm_buildDefinitions
}

# We should break this out
# We should make it easier to manager multiple architectures (and have a RPM / Debian architecture map)
core_functions_register _swaddle_package_functions swaddle_package_defaultConfiguration
swaddle_package_defaultConfiguration()
{
	core_TODO 'Make version/iteration (a release counter, perhaps) something that can be build-related / base it on git [much more sensible]'
	core_TODO 'Make it easier to have multiple architectures'
	swaddle_architecture='all'
	swaddle_epoch=0
	swaddle_version=0
	# iteration is for packaging changes as opposed to software changes.
	# This becomes a bit moot when your packaging is integrated into your build
	swaddle_iteration=0
	#swaddle_vendor=stormmq
	#swaddle_licence=GPLv3+
	swaddle_category=none
	#swaddle_maintainer='<raphael.cohn@stormmq.com>'
	#swaddle_description='no description'
	#swaddle_url="http://github.com/swaddle/${swaddle_package}"
	core_variable_array_initialise swaddle_configFiles
	core_variable_array_initialise swaddle_directories

	core_variable_array_initialise swaddle_rpm_depends
	swaddle_rpm_autoDepends=yes
	core_variable_array_initialise swaddle_rpm_provides
	core_variable_array_initialise swaddle_rpm_conflicts
	core_variable_array_initialise swaddle_rpm_replaces
	swaddle_rpm_user='root'
	swaddle_rpm_group='root'
	swaddle_rpm_defattrfile='-'
	swaddle_rpm_defattrdir='-'
	swaddle_rpm_digest='md5'
	swaddle_rpm_compression='gzip'
	swaddle_rpm_sign=no
	swaddle_rpm_autoAddDirectories=yes
	swaddle_rpm_autoReqProv=yes
	swaddle_rpm_autoReq=yes
	swaddle_rpm_autoProv=yes
	swaddle_rpm_ignoreIterationInDependencies=no
	swaddle_rpm_regexFilterFromProvides=
	swaddle_rpm_regexFilterFromRequires=
	core_variable_array_initialise swaddle_rpm_buildDefinitions
}

core_functions_register _swaddle_package_functions swaddle_package_loadConfiguration
swaddle_package_loadConfiguration()
{
	local configurationFilePath="$_swaddle_package_swaddlePath"/package.conf
	if core_path_isReadableNonEmptyFilePath "$configurationFilePath"; then
		. "$configurationFilePath" || core_exitError $core_commandLine_exitCode_CONFIG "Could not source configuration file '$configurationFilePath' for package '$swaddle_package'"
	fi
	
	local configurationFilesFolderPath="$_swaddle_package_swaddlePath"/package.conf.d
	if ! core_path_isReadableAndSearchableFolderPath "$configurationFilesFolderPath"; then
		return 0
	fi
	
	set +f
	for configurationFilePath in "$configurationFilesFolderPath"/*.conf
	do
		set -f
		if core_path_isReadableNonEmptyFilePath "$configurationFilePath"; then
			. "$configurationFilePath" || core_exitError $core_commandLine_exitCode_CONFIG "Could not source configuration file '$configurationFilePath' for package '$swaddle_package'"	
		fi
	done
	set -f
}

core_functions_register _swaddle_package_functions swaddle_package_verifyConfiguration
swaddle_package_verifyConfiguration()
{
	local configurationSetting
	for configurationSetting in vendor licence maintainer description url
	do
		if core_variable_isUnset "swaddle_$configurationSetting"; then
			core_exitError $core_commandLine_exitCode_CONFIG "The package configuration setting 'swaddle_$configurationSetting' has not be specified in configuration for the package '$swaddle_package'"
		fi
	done
	
	for configurationSetting in description group epoch version iteration category vendor licence maintainer description url
	do
		local core_variable_indirectValue_result
		core_variable_indirectValue "swaddle_$configurationSetting"
		if [ -z "$core_variable_indirectValue_result" ]; then
			core_exitError $core_commandLine_exitCode_CONFIG "The package configuration setting 'swaddle_$configurationSetting' can not be empty for the package '$swaddle_package'"
		fi
	done
	
	for configurationSetting in rpm_autoDepends rpm_sign rpm_autoAddDirectories rpm_autoReqProv rpm_autoReq rpm_autoProv rpm_ignoreIterationInDependencies
	do
		local core_variable_indirectValue_result
		core_variable_indirectValue "swaddle_$configurationSetting"
		if core_variable_isInvalidBoolean "$core_variable_indirectValue_result"; then
			core_exitError $core_commandLine_exitCode_CONFIG "The package configuration setting 'swaddle_$configurationSetting' is not a valid boolean for package '$swaddle_package'"
		fi
	done
	
	case "$swaddle_rpm_digest" in
		
		md5|sha1|sha256|sha384|sha512)
			:
		;;
		
		*)
			core_exitError $core_commandLine_exitCode_CONFIG "The package configuration setting 'swaddle_rpm_compression' is '$swaddle_rpm_digest' (it must be one of 'md5', 'sha1', 'sha256', 'sha384' or 'sha512')."
		;;
	esac
	
	case "$swaddle_rpm_compression" in
		
		none|gzip|bzip2|xz)
			:
		;;
		
		*)
			core_exitError $core_commandLine_exitCode_CONFIG "The package configuration setting 'swaddle_rpm_compression' is '$swaddle_rpm_compression' (it must be one of 'none', 'xz'. 'gzip' or 'bzip2')."
		;;
	esac
}

core_dependency_requires '*' rsync
core_functions_register _swaddle_package_functions swaddle_package_synchronisePackageSkeletonToPackageRoot
swaddle_package_synchronisePackageSkeletonToPackageRoot()
{
	local packageSkeletonPath="$_swaddle_package_swaddlePath"/skeleton
	
	if ! core_path_isReadableAndSearchableFolderPath "$packageSkeletonPath"; then
		core_message WARN "Skipping package '$swaddle_package' skeleton path '$packageSkeletonPath' because it is not readable or searchable. This is usually not what you want."
		packageSkeletonPath="$swaddle_emptyFolderSoWeCanLeverageRsyncToRemoveBodyPath"
	fi
	
	rsync --quiet --archive --acls --xattrs --hard-links --delete --delete-after --delete-excluded --exclude=.gitignore --exclude=.hgignore "$packageSkeletonPath"/ "$_swaddle_package_root"/
}

core_dependency_requires '*' rsync
core_functions_register _swaddle_package_functions swaddle_package_synchronisePackageBodyToPackageRoot
swaddle_package_synchronisePackageBodyToPackageRoot()
{
	local packageBodyPath="$_swaddle_package_swaddlePath"/body
	
	if ! core_path_isReadableAndSearchableFolderPath "$packageBodyPath"; then
		core_message INFO "Skipping package '$swaddle_package' body path '$packageBodyPath' because it is not readable or searchable."
		return 0
	fi
	
	rsync --quiet --archive --acls --xattrs --hard-links --exclude=.gitignore --exclude=.hgignore "$packageBodyPath"/ "$_swaddle_package_root"/
}

core_usesIn swaddle/package rpm
core_functions_register _swaddle_package_functions swaddle_package_create
# rpm for rpmbuild
core_dependency_requires '*' fpm rpm
swaddle_package_create()
{
	local options
	local options_initialised
	core_variable_array_initialise options
    
	if [ $(core_init_verbosity) -gt 0 ]; then
		_swaddle_package_appendSwitch verbose
	fi
	
	if [ $(core_init_verbosity) -gt 1 ]; then
		_swaddle_package_appendSwitch debug
		_swaddle_package_appendSwitch debug-workspace
	fi
	
    _swaddle_package_appendSwitch 'force'
	
    _swaddle_package_appendSwitch 's' 'dir'
	
    _swaddle_package_appendSwitch 'package' "$swaddle_outputPath"
    _swaddle_package_appendSwitch 'workdir' "$_swaddle_package_workFolderPath"
    _swaddle_package_appendSwitch 'license' "$swaddle_licence"
    _swaddle_package_appendSwitch 'vendor' "$swaddle_vendor"
    _swaddle_package_appendSwitch 'category' "$swaddle_category"
    _swaddle_package_appendSwitch 'name' "$swaddle_package"
    _swaddle_package_appendSwitch 'epoch' "$swaddle_epoch"
    _swaddle_package_appendSwitch 'version' "$swaddle_version"
    _swaddle_package_appendSwitch 'iteration' "$swaddle_iteration"
    _swaddle_package_appendSwitch 'architecture' "$swaddle_architecture"
    _swaddle_package_appendSwitch 'maintainer' "$swaddle_maintainer"
    _swaddle_package_appendSwitch 'description' "$swaddle_description"
    _swaddle_package_appendSwitch 'url' "$swaddle_url"
    
	_swaddle_package_appendArrayOfPaths 'config-files' swaddle_configFiles
	_swaddle_package_appendArrayOfPaths 'directories' swaddle_directories
		
	_swaddle_package_appendScript before-install
	_swaddle_package_appendScript after-install
	_swaddle_package_appendScript before-remove
	_swaddle_package_appendScript after-remove
    
	swaddle_package_rpm_create
	
    _swaddle_package_appendSwitch 'C' "$_swaddle_package_root"
	
	# Package contents
	core_variable_array_append options '--'
    
    local fileOrFolderToInclude
	local count=0
    pushd "$_swaddle_package_root"
        
		set +f
        for fileOrFolderToInclude in *
        do
			set -f
            if [ -e "$fileOrFolderToInclude" ]; then
				core_variable_array_append options "$fileOrFolderToInclude"
				count=$((count+1))
            fi
			
        done
		set +f
    
    popd
    
	if [ $count -eq 0 ]; then
		core_exitError $core_commandLine_exitCode_CONFIG "We need at least one file or folder in the package root (eg your skeleton or body is empty) for package '$swaddle_package'"
	fi
	
	_swaddle_package_create_fpmInfo()
	{
		local formattedArguments="$(printf " '%s'" "$@")"
		core_message INFO "About to run: fpm $formattedArguments"
	}
	
	if [ $(core_init_verbosity) -gt 1 ]; then
		core_variable_array_passToFunctionAsArguments options _swaddle_package_create_fpmInfo
	fi
	
	local stdoutLogFilePath="$_swaddle_package_temporaryFolderPath"/fpm.stdout.log
	local stderrLogFilePath="$_swaddle_package_temporaryFolderPath"/fpm.stderr.log
	core_variable_array_passToFunctionAsArguments options fpm 1>"$stdoutLogFilePath" 2>"$stderrLogFilePath" || core_exitError $core_commandLine_exitCode_CANTCREAT "fpm failed: check '$stdoutLogFilePath' and '$stderrLogFilePath'. Also try running with '--verbose 2'"
}

core_functions_register _swaddle_package_functions swaddle_package_removeWorkFolderPath
swaddle_package_removeWorkFolderPath()
{
	rm -rf "$_swaddle_package_workFolderPath"
}

core_functions_register _swaddle_package_functions swaddle_package_done
swaddle_package_done()
{
	core_message NOTICE "Built swaddle '$swaddle_package'"
}

_swaddle_package_appendSwitch()
{
	local switchName="$1"
	shift 1
	
	local prefix
	if [ ${#switchName} -eq 1 ]; then
		prefix='-'
	else
		prefix='--'
	fi
	
	core_variable_array_append options ${prefix}${switchName} "$@"
}

_swaddle_package_appendArray()
{
    local switchName="$1"
	local arrayName="$2"
	
	_swaddle_package_appendArray_callback()
	{
		_swaddle_package_appendSwitch ${switchName} "$core_variable_array_element"
	}
	core_variable_array_iterate "$arrayName" _swaddle_package_appendArray_callback
}

_swaddle_package_appendArrayOfPaths()
{
    local switchName="$1"
	local arrayName="$2"
	
	_swaddle_package_appendArrayOfPaths_callback()
	{
		local path="$core_variable_array_element"
		if core_variable_doesNotStartWith "$path" '/'; then
			core_exitError $core_commandLine_exitCode_DATAERR "Config files and directories must be absolute"
		fi
		_swaddle_package_appendSwitch ${switchName} "$path"
	}
	core_variable_array_iterate "$arrayName" _swaddle_package_appendArrayOfPaths_callback
}

_swaddle_package_appendBoolean()
{
	local switchName="$1"
	local booleanArgumentName="$2"
	
	local core_variable_indirectValue_result
	core_variable_indirectValue "$booleanArgumentName"
	
	local switch
	if core_variable_isFalse "$core_variable_indirectValue_result"; then
		switch="no-${switchName}"
	else
		switch="${switchName}"
	fi
	
    _swaddle_package_appendSwitch "$switch"
}

_swaddle_package_appendScript()
{
	local scriptType="$1"
	if _swaddle_package_makeScript "$scriptType"; then
		_swaddle_package_rpm_appendSwitch "$scriptType" "$_swaddle_package_scriptsFolderPath"/"$scriptType"
	fi
}

core_dependency_requires '*' cat rm chmod
_swaddle_package_makeScript()
{
	local scriptType="$1"
	local scriptTypePath="$_swaddle_package_scriptsFolderPath"/"$scriptType"
	
	core_TODO 'Templated scripts, scripts in other repositories and shellshock scripts'
	
	if ! core_path_isReadableAndSearchableFolderPath "$scriptTypePath"; then
		return 1
	fi
	
	local generatedScript="$_swaddle_package_generatedScriptsFolderPath"/"$scriptType"
	printf '%s\n\n' '/bin/sh' >"$generatedScript"
	
	local scriptFragment
	local count=0
	pushd "$scriptTypePath"
	
		set +f
		for scriptFragment in *
		do
			set -f
			if core_path_isReadableNonEmptyFilePath "$scriptFragment"; then
				count=$((count+1))
				printf '\n\n# %s\n' "$scriptFragment"
				cat "$scriptFragment" >>"$generatedScript"
			fi
		done
		set -f
		
	popd
	
	if [ $count -eq 0 ]; then
		rm "$generatedScript"
		return 1
	fi
	
	chmod +x "$generatedScript"
	return 0
}
