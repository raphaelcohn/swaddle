core_usesIn core variable variable/array

_configure_configurationNamespace()
{
	configurationSettingNamespace="${_program_namespace}_build_configuration_namespace_${namespace}"
}

_configure_configurationSettingValue()
{
	local key="${namespace}_${configurationSettingName}"
	configurationSettingValue="${_program_namespace}_build_configuration_value_${key}"
}

_configure_configurationSetting()
{
	local namespace="$1"
	local configurationSettingName="$2"
	local key="${namespace}_${configurationSettingName}"
	_configure_configurationNamespace
	_configure_configurationSettingValue
	configurationSettingValidate="${_program_namespace}_build_configuration_validate_${key}"
	configurationSettingDefault="${_program_namespace}_build_configuration_default_${key}"
	configurationSettingIsArray="${_program_namespace}_build_configuration_isArray_${key}"
}

_configure_configurationSettingIsArray()
{
	local core_variable_indirectValue_result
	core_variable_indirectValue "$configurationSettingIsArray"
	core_variable_isTrue "$core_variable_indirectValue_result"
}

configure_getConfigurationSetting()
{
	local namespace="$1"
	local configurationSettingName="$2"
	local configurationSettingValue
	local configurationSettingValidate
	local configurationSettingDefault
	local configurationSettingIsArray
	_configure_configurationSetting "$namespace" "$configurationSettingName"

	local core_variable_indirectValue_result
	core_variable_indirectValue "$configurationSettingValue"
	printf '%s' "$core_variable_indirectValue_result"
}

configure_register()
{
	local kind="$1"
	local configurationValidationFunction="configure_validate${2}"
	local namespace="$3"
	local configurationSettingName="$4"
	
	case "$kind" in
		
		Array)
			if [ $# -gt 4 ]; then
				core_exitError $core_commandLine_exitCode_SOFTWARE "Arrays can not have default values"
			fi
		;;
		
		Value)
			:
		;;
		
		*)
			core_exitError $core_commandLine_exitCode_SOFTWARE "kind '$kind' is unrecognised (must be one of 'Array' or 'Value')"
		;;
		
	esac
	
	local configurationSettingNamespace
	local configurationSettingValue
	local configurationSettingValidate
	local configurationSettingDefault
	local configurationSettingIsArray
	_configure_configurationSetting "$namespace" "$configurationSettingName"
	
	if core_variable_isSet "$configurationSettingValidate"; then
		core_message NOTICE "The configuration setting '$configurationSettingValidate' is already registered"
		return 0
	fi
	
	core_variable_setVariable "$configurationSettingValidate" "$configurationValidationFunction"
	
	core_variable_array_append "$configurationSettingNamespace" "$configurationSettingName"
	
	if [ "$kind" = 'Array' ]; then
		core_variable_setVariable "$configurationSettingIsArray" 'yes'
	else
		core_variable_setVariable "$configurationSettingIsArray" 'no'
	fi
	
	if [ $# -eq 4 ]; then
		return 0
	fi
	shift 4
	
	IFS=' ' local configurationSettingDefaultValue="$*"
	
	if core_variable_isUnset "$configurationSettingDefault"; then
		$configurationValidationFunction "$configurationSettingDefaultValue"
		core_variable_setVariable "$configurationSettingDefault" "$configurationSettingDefaultValue"
	fi
}

configure_reset()
{
	local namespace="$1"

	local configurationSettingNamespace
	_configure_configurationNamespace
	
	_configure_reset_callback()
	{
		local configurationSettingName="$core_variable_array_element"
		local configurationSettingValue
		local configurationSettingValidate
		local configurationSettingDefault
		local configurationSettingIsArray
		_configure_configurationSetting "$namespace" "$configurationSettingName"

		if _configure_configurationSettingIsArray; then
			core_variable_array_unset "$configurationSettingValue"
			core_variable_array_initialise "$configurationSettingValue"
		else
			core_variable_unset "$configurationSettingValue"
			
			if core_variable_isSet "$configurationSettingDefault"; then
				local core_variable_indirectValue_result
				core_variable_indirectValue "$configurationSettingDefault"
				core_variable_setVariable "$configurationSettingValue" "$core_variable_indirectValue_result"
			fi
		fi
	}
	core_variable_array_iterate "$configurationSettingNamespace" _configure_reset_callback
}

# eg  configure swaddle architecture amd64
# eg  configure swaddle description <<EOF stuff EOF
configure()
{
	local namespace="$1"
	local configurationSettingName="$2"
	shift 2
	if [ $# -ne 0 ]; then
		IFS=' ' local value="$*"
	else
		local value="$(cat)"
	fi
	
	local configurationSettingNamespace
	local configurationSettingValue
	local configurationSettingValidate
	local configurationSettingDefault
	local configurationSettingIsArray
	_configure_configurationSetting "$namespace" "$configurationSettingName"
	
	local validateFunction
	local core_variable_indirectValue_result
	core_variable_indirectValue "$configurationSettingValidate"
	$core_variable_indirectValue_result "$value"
	
	if _configure_configurationSettingIsArray; then
		core_variable_array_append "$configurationSettingValue" "$value"
	else
		core_variable_setVariable "$configurationSettingValue" "$value"
	fi
}

configure_source()
{
	local configurationPath="$1"
	local configurationName="$2"
	local configurationFilePath="$configurationPath"/"$configurationName".conf
	if core_path_isReadableNonEmptyFilePath "$configurationFilePath"; then
		. "$configurationFilePath" || core_exitError $core_commandLine_exitCode_DATAERR "Could not source configuration '$configurationFilePath' for swaddle '$_swaddle_build_swaddleName'"
	fi
	
	local configurationFolderPath="$configurationPath"/"$configurationName".conf.d
	if core_path_isReadableAndSearchableFolderPath "$configurationFolderPath"; then
		pushd "$configurationFolderPath"
			set +f
			for configurationFilePath in *.conf
			do
				set -f
				if core_path_isReadableNonEmptyFilePath "$configurationFilePath"; then
					. "$configurationFilePath" || core_exitError $core_commandLine_exitCode_DATAERR "Could not source configuration '$configurationFilePath' for swaddle '$_swaddle_build_swaddleName'"
				fi
			done
			set -f
		popd
	fi
}

configure_validate()
{
	local namespace="$1"
	
	_configure_validate_callback()
	{
		local configurationSettingName="$core_variable_array_element"
		local configurationSettingValue
		local configurationSettingValidate
		local configurationSettingDefault
		local configurationSettingIsArray
		_configure_configurationSetting "$namespace" "$configurationSettingName"
	
		if _configure_configurationSettingIsArray; then
			continue
		fi
		if core_variable_isUnset "$configurationSettingValue"; then
			core_exitError $core_commandLine_exitCode_CONFIG "The configuration setting '$namespace $configurationSettingName' can not be unset"
		fi
	}
	
	local configurationSettingNamespace
	_configure_configurationNamespace
	core_variable_array_iterate "$configurationSettingNamespace" _configure_validate_callback
}

configure_validateNotEmpty()
{
	if [ -z "$1" ]; then
		core_exitError $core_commandLine_exitCode_CONFIG "The configuration setting '$configurationSettingName' can not be empty"
	fi
}

configure_validateBoolean()
{
	if core_variable_isInvalidBoolean "$1"; then
		core_exitError $core_commandLine_exitCode_CONFIG "The configuration setting '$configurationSettingName' ('$1') is not a valid boolean"
	fi
}

configure_validateReadableSearchableFolderPath()
{
	if ! core_path_isReadableAndSearchableFolderPath "$1"; then
		core_exitError $core_commandLine_exitCode_CONFIG "The configuration setting '$configurationSettingName' ('$1') is not a readable, searchable folder path"
	fi
}

configure_validateArchitecture()
{
	case "$1" in
		
		# Currently, we only support these
		all|noarch|x86_64|amd64)
			:
		;;

		*)
			core_exitError $core_commandLine_exitCode_CONFIG "The configuration setting '$configurationSettingName' ('$1') is not a valid architecture (it must be one of 'all' or 'amd64')."
		;;
		
	esac
}

configure_validateDigest()
{
	case "$1" in

		md5|sha1|sha256|sha384|sha512)
			:
		;;

		*)
			core_exitError $core_commandLine_exitCode_CONFIG "The configuration setting '$configurationSettingName' ('$1') is not a valid digest (it must be one of 'md5', 'sha1', 'sha256', 'sha384' or 'sha512')."
		;;
		
	esac
}

configure_validateCompression()
{
	case "$1" in

		none|gzip|bzip2|lzma|xz)
			:
		;;

		*)
			core_exitError $core_commandLine_exitCode_CONFIG "The configuration setting '$configurationSettingName' ('$1') is not a valid compression (it must be one of 'none', 'gzip', 'bzip2', 'lzma' or 'xz')."
		;;
		
	esac
}

# Derived from https://fedoraproject.org/wiki/Licensing:Main?rd=Licensing
core_snippet_embed raw swaddle_licence
configure_validateLicence()
{
	_configure_validateValue licence "$1"
}

# Some rules on the GROUP TAG: https://docs.fedoraproject.org/en-US/Fedora_Draft_Documentation/0.1/html/Packagers_Guide/chap-Packagers_Guide-Spec_File_Reference-Preamble.html
# Derived from /usr/share/doc/rpm-4.8.0/ on Centos 6.5
core_snippet_embed raw swaddle_rpm_group
configure_validateRpmGroup()
{
	_configure_validateValue group "$1"
	
	if core_variable_endsWith "$_swaddle_build_swaddleName" '-doc'; then
		if [ "$1" != 'Documentation' ]; then
			core_exitError $core_commandLine_exitCode_CONFIG "The configuration setting '$configurationSettingName' ('$1') ends in '-doc' so its rpm_group must be 'Documentation', not '$1'."
		fi
	fi
}

_configure_validateValue()
{
	local valueKind="$1"
	local configurationSettingValue="$2"
	
	local snippetName="${namespace}_${valueKind}"
	
	local TMP_FILE
	core_temporaryFiles_newFileToRemoveOnExit
	core_snippet_retrieve "$snippetName" no "$TMP_FILE"
	local validValuesFilePath="$TMP_FILE"

	local validValue
	local found=0
	while IFS='' read -r validValue
	do
		if [ "$configurationSettingValue" = "$validValue" ]; then
			found=1
			break
		fi
	done <"$validValuesFilePath"
	
	if [ $found -eq 0 ]; then
		core_message WARN "The swaddle '$_swaddle_build_swaddleName' configuration setting '$configurationSettingName' ('$configurationSettingValue') is not a valid $valueKind."
	fi
	
	rm "$validValuesFilePath"
}
